# 621. Task Scheduler

链接：https://leetcode-cn.com/problems/task-scheduler/

## 贪心解法

统计任务的数量后，每次执行 `n+1` 个数量最多的任务，直到任务执行完毕。

以下解法是使用 `map` + 插入排序算法实现的。

```go
func leastInterval(tasks []byte, n int) int {
    if n==0 { return len(tasks) }
    n++
    ans, ts := 0, NewTaskScheduler(tasks)
    for {
        count := ts.Run(n)
        if !ts.IsEmpty() {
            ans += n
        } else {
            ans += count
            break
        }
    }
    return ans
}

type Task struct {
    count int
    task byte
}

type TaskScheduler struct {
    tasks map[byte]*Task
}

func NewTaskScheduler(tasks []byte) *TaskScheduler {
    ts := &TaskScheduler{tasks: make(map[byte]*Task)}
    _task := map[byte]int{}
    for _, tsk := range tasks {
        _task[tsk]++
    }
    for t, c := range _task {
        ts.tasks[t] = &Task{c, t}
    }
    return ts
}

func (ts *TaskScheduler) IsEmpty() bool {
    return len(ts.tasks)==0
}

func (ts *TaskScheduler) Run(n int) int {
    tasks, sorted := make([]*Task, 0, n), false
    for _, t := range ts.tasks {
        if len(tasks)!=n {
            tasks = append(tasks, t)
            continue
        }

        if !sorted {
            sort.Slice(tasks, func(i, j int) bool {
                return tasks[i].count<tasks[j].count
            })
            sorted = true
        }
        if t.count>tasks[0].count {
            tasks[0] = t
            reorderTasks(tasks)
        }
    }

    for _, t := range tasks {
        tsk := ts.tasks[t.task]
        tsk.count--
        if tsk.count==0 { delete(ts.tasks, t.task) }
    }
    return len(tasks)
}

func reorderTasks(tasks []*Task) {
    tsk := tasks[0]
    idx := 1
    for ; idx<len(tasks)&&tasks[idx].count<tsk.count; idx++ {}
    if idx!=1 {
        copy(tasks[:idx-1], tasks[1:idx])
        tasks[idx-1] = tsk
    }
}
```

### 解法效果

效果惨淡，有待优化。

![621_task_scheduler](./img/621_task_scheduler.png)