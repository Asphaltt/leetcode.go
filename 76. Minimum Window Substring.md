# 76. Minimum Window Substring

链接：https://leetcode-cn.com/problems/minimum-window-substring/

## 散列表 + 滑动窗口解法

1. 使用散列表去记录字符数量，并通过散列表去判断滑动窗口内的字符串是否包含目标字符串
2. 滑动窗口的左边界
3. 滑动窗口的右边界

```go
func minWindow(s string, t string) string {
    var schars, tchars ['z'+1]int
    tletters := map[byte]struct{}{}
    for i:=0; i<len(t); i++ {
        tchars[t[i]]++
        tletters[t[i]] = struct{}{}
    }

    containChar := func(b byte) bool {
        return tchars[b]!=0
    }
    
    containChars := func() bool {
        for b := range tletters {
            if schars[b]<tchars[b] { return false }
        }
        return true
    }

    slideOffset := func(b byte, offset int) int {
        schars[b]--
        for offset++; offset<len(s)&&!containChar(s[offset]); offset++ {
            schars[s[offset]]--
        }
        return offset
    }

    slideI := func(b byte, i int) int {
        for i++; i<len(s)&&s[i]!=b; i++ {
            schars[s[i]]++
        }
        return i
    }

    offset := 0
    for ; offset<len(s)&&tchars[s[offset]]==0; offset++ {
        schars[s[offset]]++
    }

    minWin, found := s, false
    for i:=offset; i<len(s); {
        schars[s[i]]++
        if !containChars() {
            i++
            continue
        }

        found = true
        if (i-offset+1)<len(minWin) {
            minWin = s[offset:i+1]
        }

        b := s[offset]
        offset = slideOffset(b, offset)
        for containChars() {
            if (i-offset+1)<len(minWin) {
                minWin = s[offset:i+1]
            }
            b = s[offset]
            offset = slideOffset(b, offset)
        }
        i = slideI(b, i)
    }
    if found { return minWin }
    return ""
}
```

## 解法效果

![76. minimum-window-substring](./img/76. minimum-window-substring.png)

## 测试用例

```txt
"ADOBECODEBANC"
"ABC"
"a"
"a"
"ADOBECODEBANC"
"AB"
"ADOBECODEBANC"
"BC"
"ADOBECODEBANC"
"AE"
"a"
"aa"
"aaaaaabacadaea"
"aaaaaa"
"aaaaaaaabbbbbbbbbcccc"
"abbbbccc"
"aaaaaaaabbbbbbbbbcccc"
"abbbbccccc"
```

